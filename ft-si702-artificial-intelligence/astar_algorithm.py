# -*- coding: utf-8 -*-
"""AlgoritmoA*.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A9kKPtsX_xCCqaN9L1Qs5FzBikFiziK3

#<h1><center> Viagem Interplanetária</h1></center>
"""

import json
import pandas as pd
from collections import deque

"""## Estruturas de dados"""

#Graph: main class of all project. is responsible for recieve the heuristc list, and the adjacent plantes list to execute the A* algorithm.
class Graph:
    def __init__(self, heur_list, adjac_lis):
        self.heur_list = heur_list
        self.adjac_lis = adjac_lis

    #get_neighbors: to obtain all neighbors of given planet.
    def get_neighbors(self, v):
        return self.adjac_lis[v]
 
    #h: This is heuristic function which is having equal values for all nodes
    def h(self, n):
        return self.heur_list[n]

    #a_star_algorithm: the main function, given the start planet and the stop planet it will execute the a* and print the open/closed lists and the result.
    def a_star_algorithm(self, start, stop):
        # In this open_lst is a lisy of nodes which have been visited, but who's 
        # neighbours haven't all been always inspected, It starts off with the start node
        # And closed_lst is a list of nodes which have been visited
        # and who's neighbors have been always inspected
        open_lst = set([start])
        closed_lst = set([])
 
        # poo has present distances from start to all other nodes
        # the default value is +infinity
        poo = {}
        poo[start] = 0
 
        # par contains an adjacent mapping of all nodes
        par = {}
        par[start] = start
        iters = -1

        while len(open_lst) > 0:
            n = None
 
            # it will find a node with the lowest value of f() , (n=node selected).
            for v in open_lst:
                if n == None or (poo[v] + self.h(v)) < (poo[n] + self.h(n)):
                    n = v;
 
            if n == None:
                print('Caminho não existe!')
                return None
 
            # if the current node is the stop, then we start again from start:
            if n == stop:
                reconst_path = []
 
                while par[n] != n:
                    reconst_path.append(n)
                    n = par[n]
 
                reconst_path.append(start)
                reconst_path.reverse()
                print('Caminho final: {}'.format(reconst_path))

                return reconst_path
 
            # for all the neighbors of the current node do:
            for (m, weight) in self.get_neighbors(n):
                # if the current node is not present in both open_lst and closed_lst
                # add it to open_lst and note n as it's par
                if m not in open_lst and m not in closed_lst:
                    open_lst.add(m)
                    par[m] = n
                    poo[m] = poo[n] + weight
 
                # otherwise, check if it's quicker to first visit n, then m
                # and if it is, update par data and poo data
                # and if the node was in the closed_lst, move it to open_lst
                else:
                    if poo[m] > poo[n] + weight:
                        poo[m] = poo[n] + weight
                        par[m] = n
 
                        if m in closed_lst:
                            closed_lst.remove(m)
                            open_lst.add(m)
 
            # remove n from the open_lst, and add it to closed_lst
            # because all of his neighbors were inspected
            open_lst.remove(n)
            closed_lst.add(n)
            iters += 1
            print(f'Iteração: {iters}')
            print(f'Lista aberta: {list(open_lst)}')
            print(f'Lista fechada: {list(closed_lst)}')
            print()
 
        print('Caminho não existe!')
        return None

def read_json(path='./dados/grafo.json'):
  f = open (path, "r")
  data = json.loads(f.read())
  adjac_lis = {}
  for i in range(len(data['adjac_list'])):
    dic = data['adjac_list'][i]
    origin_planet = list(dic.keys())[0]
    n = len(data['adjac_list'][i][origin_planet])
    planet_list = []
    for j in range(n):
      planet = tuple(data['adjac_list'][i][origin_planet][j].values())
      planet_list.append(planet)
    adjac_lis[origin_planet] = planet_list
  f.close()
  return adjac_lis

# Importando grafo
adjac_lis = read_json()
adjac_lis

# Arquivo com as funções heurísticas
tabela_heur = pd.read_csv('./dados/heuristicas.csv', index_col=0)
tabela_heur

# As 4 funções heurísticas
heur_lis_normal = tabela_heur['A*_normal']
heur_lis_burmin = tabela_heur['A*_buraco_minhoca']
heur_lis_ast = tabela_heur['A*_asteroides']
heur_lis_nadm = tabela_heur['A*_nao_admissivel']

"""## A* admissível"""

graph1 = Graph(heur_lis_normal, adjac_lis)
graph1.a_star_algorithm('Ter', 'Jup')

"""## A* com buraco de minhoca"""

graph1 = Graph(heur_lis_burmin, adjac_lis)
graph1.a_star_algorithm('Ter', 'Jup')

"""## A* com asteroides"""

graph1 = Graph(heur_lis_ast, adjac_lis)
graph1.a_star_algorithm('Ter', 'Jup')

"""## A* Não Admissível"""

graph1 = Graph(heur_lis_nadm, adjac_lis)
graph1.a_star_algorithm('Ter', 'Jup')